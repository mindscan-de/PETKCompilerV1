/*
 * generated by Xtext 2.27.0
 */
package de.mindscan.ai.aidsl.serializer;

import com.google.inject.Inject;
import de.mindscan.ai.aidsl.aiDsl.AiDslPackage;
import de.mindscan.ai.aidsl.aiDsl.AnnotationInterfaceReference;
import de.mindscan.ai.aidsl.aiDsl.BASICTYPE;
import de.mindscan.ai.aidsl.aiDsl.DataDictionaryArrayValue;
import de.mindscan.ai.aidsl.aiDsl.DataDictionaryBooleanValue;
import de.mindscan.ai.aidsl.aiDsl.DataDictionaryMapValue;
import de.mindscan.ai.aidsl.aiDsl.DataDictionaryNullValue;
import de.mindscan.ai.aidsl.aiDsl.DataDictionaryStringValue;
import de.mindscan.ai.aidsl.aiDsl.DataDictionaryValue;
import de.mindscan.ai.aidsl.aiDsl.DatadictionaryKeyValuePair;
import de.mindscan.ai.aidsl.aiDsl.ImportDeclaration;
import de.mindscan.ai.aidsl.aiDsl.LlmTaskDefinition;
import de.mindscan.ai.aidsl.aiDsl.LlmVariableAssignment;
import de.mindscan.ai.aidsl.aiDsl.Model;
import de.mindscan.ai.aidsl.aiDsl.PackageDeclaration;
import de.mindscan.ai.aidsl.aiDsl.SAIAssignment;
import de.mindscan.ai.aidsl.aiDsl.SAIBlock;
import de.mindscan.ai.aidsl.aiDsl.SAIBoolConstant;
import de.mindscan.ai.aidsl.aiDsl.SAIField;
import de.mindscan.ai.aidsl.aiDsl.SAIIfBlock;
import de.mindscan.ai.aidsl.aiDsl.SAIIfStatement;
import de.mindscan.ai.aidsl.aiDsl.SAIIntConstant;
import de.mindscan.ai.aidsl.aiDsl.SAIMemberSelection;
import de.mindscan.ai.aidsl.aiDsl.SAIMethod;
import de.mindscan.ai.aidsl.aiDsl.SAINull;
import de.mindscan.ai.aidsl.aiDsl.SAIParameter;
import de.mindscan.ai.aidsl.aiDsl.SAIReturn;
import de.mindscan.ai.aidsl.aiDsl.SAIStringConstant;
import de.mindscan.ai.aidsl.aiDsl.SAIVariableDeclaration;
import de.mindscan.ai.aidsl.aiDsl.SAIWorkflowRunStatement;
import de.mindscan.ai.aidsl.aiDsl.VMFieldElement;
import de.mindscan.ai.aidsl.aiDsl.VMNodeDefinition;
import de.mindscan.ai.aidsl.aiDsl.VMNodeFieldElements;
import de.mindscan.ai.aidsl.aiDsl.VMNodeInElement;
import de.mindscan.ai.aidsl.aiDsl.VMNodeInElements;
import de.mindscan.ai.aidsl.aiDsl.VMNodeOpCodeElement;
import de.mindscan.ai.aidsl.aiDsl.VMNodeOutElement;
import de.mindscan.ai.aidsl.aiDsl.VMNodeOutElements;
import de.mindscan.ai.aidsl.aiDsl.VMOverrideFieldElement;
import de.mindscan.ai.aidsl.aiDsl.WorkflowDataDictionaryDefinition;
import de.mindscan.ai.aidsl.aiDsl.WorkflowDefinition;
import de.mindscan.ai.aidsl.aiDsl.WorkflowDefinitionApplyLLMNodeResultAssignment;
import de.mindscan.ai.aidsl.aiDsl.WorkflowDefinitionApplyLLMTaskStatement;
import de.mindscan.ai.aidsl.aiDsl.WorkflowFunctionsDefinition;
import de.mindscan.ai.aidsl.aiDsl.WorkflowIfStatement;
import de.mindscan.ai.aidsl.aiDsl.WorkflowInputDefinition;
import de.mindscan.ai.aidsl.aiDsl.WorkflowUIElement;
import de.mindscan.ai.aidsl.aiDsl.WorkflowUIElementMap;
import de.mindscan.ai.aidsl.services.AiDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AiDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AiDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AiDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AiDslPackage.ANNOTATION_INTERFACE_REFERENCE:
				sequence_AnnotationInterfaceReference(context, (AnnotationInterfaceReference) semanticObject); 
				return; 
			case AiDslPackage.BASICTYPE:
				if (rule == grammarAccess.getBASICTYPERule()) {
					sequence_BASICTYPE(context, (BASICTYPE) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getELEMENTTYPERule()) {
					sequence_BASICTYPE_ELEMENTTYPE(context, (BASICTYPE) semanticObject); 
					return; 
				}
				else break;
			case AiDslPackage.DATA_DICTIONARY_ARRAY_VALUE:
				sequence_DataDictionaryArrayValue(context, (DataDictionaryArrayValue) semanticObject); 
				return; 
			case AiDslPackage.DATA_DICTIONARY_BOOLEAN_VALUE:
				sequence_DataDictionaryBooleanValue(context, (DataDictionaryBooleanValue) semanticObject); 
				return; 
			case AiDslPackage.DATA_DICTIONARY_MAP_VALUE:
				sequence_DataDictionaryMapValue(context, (DataDictionaryMapValue) semanticObject); 
				return; 
			case AiDslPackage.DATA_DICTIONARY_NULL_VALUE:
				sequence_DataDictionaryNullValue(context, (DataDictionaryNullValue) semanticObject); 
				return; 
			case AiDslPackage.DATA_DICTIONARY_STRING_VALUE:
				sequence_DataDictionaryStringValue(context, (DataDictionaryStringValue) semanticObject); 
				return; 
			case AiDslPackage.DATA_DICTIONARY_VALUE:
				sequence_DataDictionaryValue(context, (DataDictionaryValue) semanticObject); 
				return; 
			case AiDslPackage.DATADICTIONARY_KEY_VALUE_PAIR:
				sequence_DatadictionaryKeyValuePair(context, (DatadictionaryKeyValuePair) semanticObject); 
				return; 
			case AiDslPackage.IMPORT_DECLARATION:
				sequence_ImportDeclaration(context, (ImportDeclaration) semanticObject); 
				return; 
			case AiDslPackage.LLM_TASK_DEFINITION:
				sequence_LlmTaskDefinition(context, (LlmTaskDefinition) semanticObject); 
				return; 
			case AiDslPackage.LLM_VARIABLE_ASSIGNMENT:
				sequence_LlmVariableAssignment(context, (LlmVariableAssignment) semanticObject); 
				return; 
			case AiDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case AiDslPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case AiDslPackage.SAI_ASSIGNMENT:
				sequence_SAIAssignment(context, (SAIAssignment) semanticObject); 
				return; 
			case AiDslPackage.SAI_BLOCK:
				sequence_SAIBlock(context, (SAIBlock) semanticObject); 
				return; 
			case AiDslPackage.SAI_BOOL_CONSTANT:
				sequence_SAITerminalExpression(context, (SAIBoolConstant) semanticObject); 
				return; 
			case AiDslPackage.SAI_FIELD:
				sequence_SAITypedDeclaration(context, (SAIField) semanticObject); 
				return; 
			case AiDslPackage.SAI_IF_BLOCK:
				sequence_SAIIfBlock(context, (SAIIfBlock) semanticObject); 
				return; 
			case AiDslPackage.SAI_IF_STATEMENT:
				sequence_SAIIfStatement(context, (SAIIfStatement) semanticObject); 
				return; 
			case AiDslPackage.SAI_INT_CONSTANT:
				sequence_SAITerminalExpression(context, (SAIIntConstant) semanticObject); 
				return; 
			case AiDslPackage.SAI_MEMBER_SELECTION:
				sequence_SAISelectionExpression(context, (SAIMemberSelection) semanticObject); 
				return; 
			case AiDslPackage.SAI_METHOD:
				sequence_SAIMethod_SAITypedDeclaration(context, (SAIMethod) semanticObject); 
				return; 
			case AiDslPackage.SAI_NULL:
				sequence_SAITerminalExpression(context, (SAINull) semanticObject); 
				return; 
			case AiDslPackage.SAI_PARAMETER:
				sequence_SAITypedDeclaration(context, (SAIParameter) semanticObject); 
				return; 
			case AiDslPackage.SAI_RETURN:
				sequence_SAIReturn(context, (SAIReturn) semanticObject); 
				return; 
			case AiDslPackage.SAI_STRING_CONSTANT:
				sequence_SAITerminalExpression(context, (SAIStringConstant) semanticObject); 
				return; 
			case AiDslPackage.SAI_VARIABLE_DECLARATION:
				sequence_SAITypedDeclaration_SAIVariableDeclaration(context, (SAIVariableDeclaration) semanticObject); 
				return; 
			case AiDslPackage.SAI_WORKFLOW_RUN_STATEMENT:
				sequence_SAIWorkflowRunStatement(context, (SAIWorkflowRunStatement) semanticObject); 
				return; 
			case AiDslPackage.VM_FIELD_ELEMENT:
				sequence_VMFieldElement(context, (VMFieldElement) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_DEFINITION:
				sequence_VMNodeDefinition(context, (VMNodeDefinition) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_FIELD_ELEMENTS:
				sequence_VMNodeFieldElements(context, (VMNodeFieldElements) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_IN_ELEMENT:
				sequence_VMNodeInElement(context, (VMNodeInElement) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_IN_ELEMENTS:
				sequence_VMNodeInElements(context, (VMNodeInElements) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_OP_CODE_ELEMENT:
				sequence_VMNodeOpCodeElement(context, (VMNodeOpCodeElement) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_OUT_ELEMENT:
				sequence_VMNodeOutElement(context, (VMNodeOutElement) semanticObject); 
				return; 
			case AiDslPackage.VM_NODE_OUT_ELEMENTS:
				sequence_VMNodeOutElements(context, (VMNodeOutElements) semanticObject); 
				return; 
			case AiDslPackage.VM_OVERRIDE_FIELD_ELEMENT:
				sequence_VMOverrideFieldElement(context, (VMOverrideFieldElement) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_DATA_DICTIONARY_DEFINITION:
				sequence_WorkflowDataDictionaryDefinition(context, (WorkflowDataDictionaryDefinition) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_DEFINITION:
				sequence_WorkflowDefinition(context, (WorkflowDefinition) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_DEFINITION_APPLY_LLM_NODE_RESULT_ASSIGNMENT:
				sequence_WorkflowDefinitionApplyLLMNodeResultAssignment(context, (WorkflowDefinitionApplyLLMNodeResultAssignment) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_DEFINITION_APPLY_LLM_TASK_STATEMENT:
				sequence_WorkflowDefinitionApplyLLMTaskStatement(context, (WorkflowDefinitionApplyLLMTaskStatement) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_FUNCTIONS_DEFINITION:
				sequence_WorkflowFunctionsDefinition(context, (WorkflowFunctionsDefinition) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_IF_STATEMENT:
				sequence_WorkflowIfStatement(context, (WorkflowIfStatement) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_INPUT_DEFINITION:
				sequence_WorkflowInputDefinition(context, (WorkflowInputDefinition) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_UI_ELEMENT:
				sequence_WorkflowUIElement(context, (WorkflowUIElement) semanticObject); 
				return; 
			case AiDslPackage.WORKFLOW_UI_ELEMENT_MAP:
				sequence_WorkflowUIElementMap(context, (WorkflowUIElementMap) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnotationInterfaceReference returns AnnotationInterfaceReference
	 *
	 * Constraint:
	 *     name=[VMNodeDefinition|ID]
	 * </pre>
	 */
	protected void sequence_AnnotationInterfaceReference(ISerializationContext context, AnnotationInterfaceReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.ANNOTATION_INTERFACE_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.ANNOTATION_INTERFACE_REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnnotationInterfaceReferenceAccess().getNameVMNodeDefinitionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(AiDslPackage.Literals.ANNOTATION_INTERFACE_REFERENCE__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BASICTYPE returns BASICTYPE
	 *
	 * Constraint:
	 *     (
	 *         typename='string' | 
	 *         typename='int' | 
	 *         typename='boolean' | 
	 *         typename='byte' | 
	 *         typename='jsonstring' | 
	 *         typename='upload'
	 *     )
	 * </pre>
	 */
	protected void sequence_BASICTYPE(ISerializationContext context, BASICTYPE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ELEMENTTYPE returns BASICTYPE
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             typename='string' | 
	 *             typename='int' | 
	 *             typename='boolean' | 
	 *             typename='byte' | 
	 *             typename='jsonstring' | 
	 *             typename='upload'
	 *         ) 
	 *         isArray?='['?
	 *     )
	 * </pre>
	 */
	protected void sequence_BASICTYPE_ELEMENTTYPE(ISerializationContext context, BASICTYPE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataDictionaryArrayValue returns DataDictionaryArrayValue
	 *
	 * Constraint:
	 *     (values+=STRING values+=STRING*)?
	 * </pre>
	 */
	protected void sequence_DataDictionaryArrayValue(ISerializationContext context, DataDictionaryArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataDictionaryBooleanValue returns DataDictionaryBooleanValue
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 * </pre>
	 */
	protected void sequence_DataDictionaryBooleanValue(ISerializationContext context, DataDictionaryBooleanValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataDictionaryMapValue returns DataDictionaryMapValue
	 *
	 * Constraint:
	 *     keyValuePairs+=DatadictionaryKeyValuePair*
	 * </pre>
	 */
	protected void sequence_DataDictionaryMapValue(ISerializationContext context, DataDictionaryMapValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataDictionaryNullValue returns DataDictionaryNullValue
	 *
	 * Constraint:
	 *     value='null'
	 * </pre>
	 */
	protected void sequence_DataDictionaryNullValue(ISerializationContext context, DataDictionaryNullValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.DATA_DICTIONARY_NULL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.DATA_DICTIONARY_NULL_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataDictionaryNullValueAccess().getValueNullKeyword_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataDictionaryStringValue returns DataDictionaryStringValue
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_DataDictionaryStringValue(ISerializationContext context, DataDictionaryStringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.DATA_DICTIONARY_STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.DATA_DICTIONARY_STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataDictionaryStringValueAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataDictionaryValue returns DataDictionaryValue
	 *
	 * Constraint:
	 *     (
	 *         value=DataDictionaryBooleanValue | 
	 *         value=DataDictionaryNullValue | 
	 *         value=DataDictionaryStringValue | 
	 *         value=DataDictionaryArrayValue | 
	 *         value=DataDictionaryMapValue
	 *     )
	 * </pre>
	 */
	protected void sequence_DataDictionaryValue(ISerializationContext context, DataDictionaryValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DatadictionaryKeyValuePair returns DatadictionaryKeyValuePair
	 *
	 * Constraint:
	 *     (name=ID extends=[DatadictionaryKeyValuePair|ID]? value=DataDictionaryValue)
	 * </pre>
	 */
	protected void sequence_DatadictionaryKeyValuePair(ISerializationContext context, DatadictionaryKeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportDeclaration returns ImportDeclaration
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 * </pre>
	 */
	protected void sequence_ImportDeclaration(ISerializationContext context, ImportDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.IMPORT_DECLARATION__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.IMPORT_DECLARATION__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportDeclarationAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LlmTaskDefinition returns LlmTaskDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (annotation_interfaces+=AnnotationInterfaceReference annotation_interfaces+=AnnotationInterfaceReference*)? 
	 *         assignments+=LlmVariableAssignment*
	 *     )
	 * </pre>
	 */
	protected void sequence_LlmTaskDefinition(ISerializationContext context, LlmTaskDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LlmVariableAssignment returns LlmVariableAssignment
	 *
	 * Constraint:
	 *     (variablename=ID template=DataDictionaryValue)
	 * </pre>
	 */
	protected void sequence_LlmVariableAssignment(ISerializationContext context, LlmVariableAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.LLM_VARIABLE_ASSIGNMENT__VARIABLENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.LLM_VARIABLE_ASSIGNMENT__VARIABLENAME));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.LLM_VARIABLE_ASSIGNMENT__TEMPLATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.LLM_VARIABLE_ASSIGNMENT__TEMPLATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLlmVariableAssignmentAccess().getVariablenameIDTerminalRuleCall_0_0(), semanticObject.getVariablename());
		feeder.accept(grammarAccess.getLlmVariableAssignmentAccess().getTemplateDataDictionaryValueParserRuleCall_2_0(), semanticObject.getTemplate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (package_declaration=PackageDeclaration import_declarations+=ImportDeclaration+) | 
	 *         (
	 *             ((package_declaration=PackageDeclaration import_declarations+=ImportDeclaration+) | import_declarations+=ImportDeclaration+)? 
	 *             (
	 *                 definitions+=WorkflowDefinition | 
	 *                 definitions+=WorkflowDataDictionaryDefinition | 
	 *                 definitions+=WorkflowInputDefinition | 
	 *                 definitions+=LlmTaskDefinition | 
	 *                 definitions+=VMNodeDefinition | 
	 *                 definitions+=WorkflowFunctionsDefinition
	 *             )+
	 *         ) | 
	 *         import_declarations+=ImportDeclaration+
	 *     )?
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     name=QualifiedName
	 * </pre>
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.PACKAGE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.PACKAGE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageDeclarationAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIAssignment
	 *     SAIExpression returns SAIAssignment
	 *     SAIAssignment returns SAIAssignment
	 *
	 * Constraint:
	 *     (left=SAIAssignment_SAIAssignment_1_0 right=SAIExpression)
	 * </pre>
	 */
	protected void sequence_SAIAssignment(ISerializationContext context, SAIAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAIAssignmentAccess().getSAIAssignmentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSAIAssignmentAccess().getRightSAIExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIBlock returns SAIBlock
	 *     SAIIfBlock returns SAIBlock
	 *
	 * Constraint:
	 *     statements+=SAIStatement*
	 * </pre>
	 */
	protected void sequence_SAIBlock(ISerializationContext context, SAIBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIIfBlock returns SAIIfBlock
	 *
	 * Constraint:
	 *     statements+=SAIStatement
	 * </pre>
	 */
	protected void sequence_SAIIfBlock(ISerializationContext context, SAIIfBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIIfStatement
	 *     SAIIfStatement returns SAIIfStatement
	 *
	 * Constraint:
	 *     (expression=SAIExpression thenblock=SAIIfBlock elseBlock=SAIIfBlock?)
	 * </pre>
	 */
	protected void sequence_SAIIfStatement(ISerializationContext context, SAIIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIMember returns SAIMethod
	 *     SAIMethod returns SAIMethod
	 *
	 * Constraint:
	 *     (type=ELEMENTTYPE name=ID (params+=SAIParameter params+=SAIParameter)? body=SAIBlock)
	 * </pre>
	 */
	protected void sequence_SAIMethod_SAITypedDeclaration(ISerializationContext context, SAIMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIReturn
	 *     SAIReturn returns SAIReturn
	 *
	 * Constraint:
	 *     expression=SAIExpression
	 * </pre>
	 */
	protected void sequence_SAIReturn(ISerializationContext context, SAIReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAIReturnAccess().getExpressionSAIExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIMemberSelection
	 *     SAIExpression returns SAIMemberSelection
	 *     SAIAssignment returns SAIMemberSelection
	 *     SAIAssignment.SAIAssignment_1_0 returns SAIMemberSelection
	 *     SAISelectionExpression returns SAIMemberSelection
	 *     SAISelectionExpression.SAIMemberSelection_1_0 returns SAIMemberSelection
	 *
	 * Constraint:
	 *     (
	 *         receiver=SAISelectionExpression_SAIMemberSelection_1_0 
	 *         member=[SAIMember|ID] 
	 *         (methodinvocation?='(' (args+=SAIExpression args+=SAIExpression*)?)?
	 *     )
	 * </pre>
	 */
	protected void sequence_SAISelectionExpression(ISerializationContext context, SAIMemberSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIBoolConstant
	 *     SAIExpression returns SAIBoolConstant
	 *     SAIAssignment returns SAIBoolConstant
	 *     SAIAssignment.SAIAssignment_1_0 returns SAIBoolConstant
	 *     SAISelectionExpression returns SAIBoolConstant
	 *     SAISelectionExpression.SAIMemberSelection_1_0 returns SAIBoolConstant
	 *     SAITerminalExpression returns SAIBoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 * </pre>
	 */
	protected void sequence_SAITerminalExpression(ISerializationContext context, SAIBoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIIntConstant
	 *     SAIExpression returns SAIIntConstant
	 *     SAIAssignment returns SAIIntConstant
	 *     SAIAssignment.SAIAssignment_1_0 returns SAIIntConstant
	 *     SAISelectionExpression returns SAIIntConstant
	 *     SAISelectionExpression.SAIMemberSelection_1_0 returns SAIIntConstant
	 *     SAITerminalExpression returns SAIIntConstant
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_SAITerminalExpression(ISerializationContext context, SAIIntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAITerminalExpressionAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAINull
	 *     SAIExpression returns SAINull
	 *     SAIAssignment returns SAINull
	 *     SAIAssignment.SAIAssignment_1_0 returns SAINull
	 *     SAISelectionExpression returns SAINull
	 *     SAISelectionExpression.SAIMemberSelection_1_0 returns SAINull
	 *     SAITerminalExpression returns SAINull
	 *
	 * Constraint:
	 *     {SAINull}
	 * </pre>
	 */
	protected void sequence_SAITerminalExpression(ISerializationContext context, SAINull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIStringConstant
	 *     SAIExpression returns SAIStringConstant
	 *     SAIAssignment returns SAIStringConstant
	 *     SAIAssignment.SAIAssignment_1_0 returns SAIStringConstant
	 *     SAISelectionExpression returns SAIStringConstant
	 *     SAISelectionExpression.SAIMemberSelection_1_0 returns SAIStringConstant
	 *     SAITerminalExpression returns SAIStringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_SAITerminalExpression(ISerializationContext context, SAIStringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAITerminalExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIMember returns SAIField
	 *     SAIField returns SAIField
	 *
	 * Constraint:
	 *     (type=ELEMENTTYPE name=ID)
	 * </pre>
	 */
	protected void sequence_SAITypedDeclaration(ISerializationContext context, SAIField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_MEMBER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_MEMBER__TYPE));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_MEMBER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_MEMBER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAITypedDeclarationAccess().getTypeELEMENTTYPEParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getSAITypedDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIParameter returns SAIParameter
	 *
	 * Constraint:
	 *     (type=ELEMENTTYPE name=ID)
	 * </pre>
	 */
	protected void sequence_SAITypedDeclaration(ISerializationContext context, SAIParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_MEMBER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_MEMBER__TYPE));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_MEMBER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_MEMBER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAITypedDeclarationAccess().getTypeELEMENTTYPEParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getSAITypedDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIVariableDeclaration
	 *     SAIVariableDeclaration returns SAIVariableDeclaration
	 *
	 * Constraint:
	 *     (type=ELEMENTTYPE name=ID expression=SAIExpression)
	 * </pre>
	 */
	protected void sequence_SAITypedDeclaration_SAIVariableDeclaration(ISerializationContext context, SAIVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_VARIABLE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_VARIABLE_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAITypedDeclarationAccess().getTypeELEMENTTYPEParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getSAITypedDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSAIVariableDeclarationAccess().getExpressionSAIExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SAIStatement returns SAIWorkflowRunStatement
	 *     SAIWorkflowRunStatement returns SAIWorkflowRunStatement
	 *
	 * Constraint:
	 *     task=[LlmTaskDefinition|ID]
	 * </pre>
	 */
	protected void sequence_SAIWorkflowRunStatement(ISerializationContext context, SAIWorkflowRunStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.SAI_WORKFLOW_RUN_STATEMENT__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.SAI_WORKFLOW_RUN_STATEMENT__TASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSAIWorkflowRunStatementAccess().getTaskLlmTaskDefinitionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(AiDslPackage.Literals.SAI_WORKFLOW_RUN_STATEMENT__TASK, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMFieldElement returns VMFieldElement
	 *
	 * Constraint:
	 *     ((policy='require' | policy='optional') type=ELEMENTTYPE name=ID defaultvalue=DataDictionaryValue?)
	 * </pre>
	 */
	protected void sequence_VMFieldElement(ISerializationContext context, VMFieldElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeDefinition returns VMNodeDefinition
	 *
	 * Constraint:
	 *     ((nodetype='super' | nodetype='overlay')? name=ID elements+=VMNodeEleemnts*)
	 * </pre>
	 */
	protected void sequence_VMNodeDefinition(ISerializationContext context, VMNodeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeEleemnts returns VMNodeFieldElements
	 *     VMNodeFieldElements returns VMNodeFieldElements
	 *
	 * Constraint:
	 *     (fieldELements+=VMFieldElement | fieldELements+=VMOverrideFieldElement)*
	 * </pre>
	 */
	protected void sequence_VMNodeFieldElements(ISerializationContext context, VMNodeFieldElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeInElement returns VMNodeInElement
	 *
	 * Constraint:
	 *     ((policy='require' | policy='optional')? name=QualifiedName)
	 * </pre>
	 */
	protected void sequence_VMNodeInElement(ISerializationContext context, VMNodeInElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeEleemnts returns VMNodeInElements
	 *     VMNodeInElements returns VMNodeInElements
	 *
	 * Constraint:
	 *     inElements+=VMNodeInElement*
	 * </pre>
	 */
	protected void sequence_VMNodeInElements(ISerializationContext context, VMNodeInElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeEleemnts returns VMNodeOpCodeElement
	 *     VMNodeOpCodeElement returns VMNodeOpCodeElement
	 *
	 * Constraint:
	 *     opcode=STRING
	 * </pre>
	 */
	protected void sequence_VMNodeOpCodeElement(ISerializationContext context, VMNodeOpCodeElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.VM_NODE_OP_CODE_ELEMENT__OPCODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.VM_NODE_OP_CODE_ELEMENT__OPCODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVMNodeOpCodeElementAccess().getOpcodeSTRINGTerminalRuleCall_1_0(), semanticObject.getOpcode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeOutElement returns VMNodeOutElement
	 *
	 * Constraint:
	 *     (name=QualifiedName type=ELEMENTTYPE (hasrequire?='require' inputreference=[VMNodeInElement|QualifiedName])?)
	 * </pre>
	 */
	protected void sequence_VMNodeOutElement(ISerializationContext context, VMNodeOutElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMNodeEleemnts returns VMNodeOutElements
	 *     VMNodeOutElements returns VMNodeOutElements
	 *
	 * Constraint:
	 *     outElements+=VMNodeOutElement*
	 * </pre>
	 */
	protected void sequence_VMNodeOutElements(ISerializationContext context, VMNodeOutElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VMOverrideFieldElement returns VMOverrideFieldElement
	 *
	 * Constraint:
	 *     (policy='override' type=ELEMENTTYPE name=ID defaultvalue=STRING)
	 * </pre>
	 */
	protected void sequence_VMOverrideFieldElement(ISerializationContext context, VMOverrideFieldElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__POLICY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__POLICY));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__TYPE));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__DEFAULTVALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.VM_OVERRIDE_FIELD_ELEMENT__DEFAULTVALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVMOverrideFieldElementAccess().getPolicyOverrideKeyword_0_0(), semanticObject.getPolicy());
		feeder.accept(grammarAccess.getVMOverrideFieldElementAccess().getTypeELEMENTTYPEParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVMOverrideFieldElementAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVMOverrideFieldElementAccess().getDefaultvalueSTRINGTerminalRuleCall_4_0(), semanticObject.getDefaultvalue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowDataDictionaryDefinition returns WorkflowDataDictionaryDefinition
	 *
	 * Constraint:
	 *     (name=ID keyValuePairs+=DatadictionaryKeyValuePair*)
	 * </pre>
	 */
	protected void sequence_WorkflowDataDictionaryDefinition(ISerializationContext context, WorkflowDataDictionaryDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowDefinitionApplyLLMNodeResultAssignment returns WorkflowDefinitionApplyLLMNodeResultAssignment
	 *
	 * Constraint:
	 *     (environmentresultname=QualifiedName noderesultname=QualifiedName)
	 * </pre>
	 */
	protected void sequence_WorkflowDefinitionApplyLLMNodeResultAssignment(ISerializationContext context, WorkflowDefinitionApplyLLMNodeResultAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.WORKFLOW_DEFINITION_APPLY_LLM_NODE_RESULT_ASSIGNMENT__ENVIRONMENTRESULTNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.WORKFLOW_DEFINITION_APPLY_LLM_NODE_RESULT_ASSIGNMENT__ENVIRONMENTRESULTNAME));
			if (transientValues.isValueTransient(semanticObject, AiDslPackage.Literals.WORKFLOW_DEFINITION_APPLY_LLM_NODE_RESULT_ASSIGNMENT__NODERESULTNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AiDslPackage.Literals.WORKFLOW_DEFINITION_APPLY_LLM_NODE_RESULT_ASSIGNMENT__NODERESULTNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkflowDefinitionApplyLLMNodeResultAssignmentAccess().getEnvironmentresultnameQualifiedNameParserRuleCall_0_0(), semanticObject.getEnvironmentresultname());
		feeder.accept(grammarAccess.getWorkflowDefinitionApplyLLMNodeResultAssignmentAccess().getNoderesultnameQualifiedNameParserRuleCall_2_0(), semanticObject.getNoderesultname());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowDefinitionApplyLLMTaskStatement returns WorkflowDefinitionApplyLLMTaskStatement
	 *
	 * Constraint:
	 *     (llmtask=[LlmTaskDefinition|ID] noderesultassigments+=WorkflowDefinitionApplyLLMNodeResultAssignment*)
	 * </pre>
	 */
	protected void sequence_WorkflowDefinitionApplyLLMTaskStatement(ISerializationContext context, WorkflowDefinitionApplyLLMTaskStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowDefinition returns WorkflowDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         input=[WorkflowInputDefinition|ID] 
	 *         datadictionary=[WorkflowDataDictionaryDefinition|ID] 
	 *         statements+=WorkflowDefinitionApplyLLMTaskStatement*
	 *     )
	 * </pre>
	 */
	protected void sequence_WorkflowDefinition(ISerializationContext context, WorkflowDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowFunctionsDefinition returns WorkflowFunctionsDefinition
	 *
	 * Constraint:
	 *     (name=ID members+=SAIMember*)
	 * </pre>
	 */
	protected void sequence_WorkflowFunctionsDefinition(ISerializationContext context, WorkflowFunctionsDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowIfStatement returns WorkflowIfStatement
	 *
	 * Constraint:
	 *     (condition='condition' elsePresent?='else'?)
	 * </pre>
	 */
	protected void sequence_WorkflowIfStatement(ISerializationContext context, WorkflowIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowInputDefinition returns WorkflowInputDefinition
	 *
	 * Constraint:
	 *     (name=ID uiElements+=WorkflowUIElement*)
	 * </pre>
	 */
	protected void sequence_WorkflowInputDefinition(ISerializationContext context, WorkflowInputDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowUIElementMap returns WorkflowUIElementMap
	 *
	 * Constraint:
	 *     (label=STRING uitype=STRING defaultvalue=DataDictionaryValue? options=DataDictionaryArrayValue?)
	 * </pre>
	 */
	protected void sequence_WorkflowUIElementMap(ISerializationContext context, WorkflowUIElementMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowUIElement returns WorkflowUIElement
	 *
	 * Constraint:
	 *     (name=QualifiedName datatype=ELEMENTTYPE uielement=WorkflowUIElementMap?)
	 * </pre>
	 */
	protected void sequence_WorkflowUIElement(ISerializationContext context, WorkflowUIElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
