grammar de.mindscan.ai.aidsl.AiDsl hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate aiDsl "http://www.mindscan.de/ai/aidsl/AiDsl"

Model:
	(package_declaration=PackageDeclaration)?
	
	(import_declarations+=ImportDeclaration)*
	
	definitions += (
		WorkflowDefinition|
		WorkflowDataDictionaryDefinition|
		WorkflowInputDefinition|
		LlmTaskDefinition|
		VMNodeDefinition|
		// This rule is a way to build the new grammar, such that we
		// transition to a more complex grammar. 
		WorkflowFunctionsDefinition
	)*
;

WorkflowFunctionsDefinition:
	'simpleaidsl' name=ID '{'
		members += SAIMember*
	'}'
;

SAIMember:
	SAIField|SAIMethod
;

SAIField:
	SAITypedDeclaration ';'
;

SAIMethod:
	SAITypedDeclaration '(' (params+=SAIParameter (',' params+=SAIParameter))? ')' 
	body=SAIBlock
;

SAIParameter:
	SAITypedDeclaration
;

SAIBlock:
	{SAIBlock}
	'{'
		statements+=SAIStatement*
	'}'
;

SAIStatement:
	SAIVariableDeclaration|
	SAIReturn|
	SAIExpression|
	SAIIfStatement
;

SAIVariableDeclaration:
	SAITypedDeclaration ':=' expression=SAIExpression
;

SAIReturn:
	'return' expression=SAIExpression ';'
;


SAIIfStatement:
	'if' '(' expression=SAIExpression ')' thenblock=SAIIfBlock
	(=> 'else' elseBlock=SAIIfBlock )?
;

SAIIfBlock:
	statements +=SAIStatement|
	SAIBlock
;

fragment SAITypedDeclaration *:
	type=[ELEMENTTYPE] name=ID
;

SAIExpression:
	SAIAssignment
;

SAIAssignment returns SAIExpression:
	SAISelectionExpression
	({SAIAssignment.left=current} ':=' right=SAIExpression )?
;

SAISelectionExpression returns SAIExpression:
	SAITerminalExpression
	(
		{SAIMemberSelection.receiver=current} '.'
		member=[SAIMember]
		( 
			methodinvocation?='('
				(args+=SAIExpression (',' args+=SAIExpression)*)?
			')'	
		)?
	)*
;

SAITerminalExpression returns SAIExpression:
	{SAIStringConstant} value=STRING |
	{SAIIntConstant} value=INT | 
	{SAIBoolConstant} value=('true'|'false') |
	{SAINull} 'null' // |
	// TODO the references to worfklows and such...
	// TODO: the reference to members and such...
	// '(' SAIExpression ')'
;


PackageDeclaration:
	'package' name=QualifiedName
;

ImportDeclaration:
	'import' importedNamespace=QualifiedNameWithWildcard
;

// should we reference the workflow or the oher way around?
WorkflowInputDefinition:
	'datainput' name=ID '{'
		(uiElements+=WorkflowUIElement)*
	'}'
;

WorkflowUIElement:
	name=QualifiedName ':' datatype=ELEMENTTYPE (uielement=WorkflowUIElementMap)? 
;

WorkflowUIElementMap:
	'ui' '{'
		'label' label=STRING
		'uitype' uitype=STRING
		// optional default value
		( 'default' defaultvalue=DataDictionaryValue )?
		// optional options value
		( 'options' options=DataDictionaryArrayValue )?
	'}'
;

// ---------------------------------------
// Workflow Data Defitinion / 
// Workflow Data Dictionary
// ---------------------------------------
//
// ---------------------------------------

WorkflowDataDictionaryDefinition:
	'datadictionary' name=ID '{'
		(keyValuePairs+=DatadictionaryKeyValuePair)*
	'}'
;

// Actually the name, should also allow for a simple string value ? Maybe not now...
DatadictionaryKeyValuePair:
	name=ID ('extends' extends=[DatadictionaryKeyValuePair])? ':' value=DataDictionaryValue
;

// TODO: we want also integers/numbers/floats
DataDictionaryValue:
	{DataDictionaryValue}
		value = 
			(
				DataDictionaryBooleanValue|
				DataDictionaryNullValue|
				DataDictionaryStringValue|
				// eigentlich sollten nur diese extendbar sein, aber das kann man auch über den parser ast
				// klären, statt über die grammar. array extands heisst, dass die liste verlängert wird / --> append operation
				DataDictionaryArrayValue|
				// bei einer map bedeutet extends, dass die werte, die im extends stehen die globalen werte ggf überschreiben. / --> merge operation
				DataDictionaryMapValue
			)
;

// TODO: rework to support also non string data values in an array
DataDictionaryArrayValue:
	 {DataDictionaryArrayValue} 
	 '[' (values+=STRING (',' values+=STRING)*)? ']'
;

DataDictionaryMapValue:
	 {DataDictionaryMapValue}  
	 '{' (keyValuePairs+=DatadictionaryKeyValuePair)* '}'
;

DataDictionaryBooleanValue:
	{DataDictionaryBooleanValue} value = ('true'|'false')
;

DataDictionaryStringValue:
	{DataDictionaryStringValue} value = STRING
;

DataDictionaryNullValue:
	{DataDictionaryNullValue} value = 'null'
;

// ---------------------------------------
// VMNode stuff
// ---------------------------------------
//  
// ---------------------------------------

VMNodeDefinition:
	'vmnode' (nodetype=('super'|'overlay'))? name=ID '{'
		(elements+=VMNodeEleemnts)*
	'}'
;

VMNodeEleemnts:
	(
		VMNodeOpCodeElement|
		VMNodeOutElements|
		VMNodeInElements|
		VMNodeFieldElements
	)
;


VMNodeOpCodeElement:
	'opcode' opcode=STRING
;

VMNodeOutElements:
	{VMNodeOutElements} 'out' '{'
		(outElements+=VMNodeOutElement)* 
	'}'
;

VMNodeInElements:
	{VMNodeInElements} 'in' '{'
		(inElements+=VMNodeInElement)*
	'}'
;

VMNodeFieldElements:
	{VMNodeFieldElements} 'fields' '{'
		(fieldELements+=(VMFieldElement|VMOverrideFieldElement))*
	'}'
;

VMNodeOutElement:
	name=QualifiedName 'as' type=ELEMENTTYPE (hasrequire?='require' inputreference=[VMNodeInElement|QualifiedName])?
;

VMNodeInElement:
	(policy=('require'|'optional'))? name=QualifiedName
;

VMFieldElement:
	policy=('require'|'optional') type=ELEMENTTYPE name=ID ('default' defaultvalue=DataDictionaryValue)?
;

// TODO rework to non string overrides
VMOverrideFieldElement:
	policy=('override') type=ELEMENTTYPE name=ID ':=' defaultvalue=STRING
;

// ---------------------------------------
// LLM Task definition
// ---------------------------------------
// 
// ---------------------------------------

LlmTaskDefinition:
	'llmtask' name=ID '(' ')' ('implements' annotation_interfaces+=AnnotationInterfaceReference (',' annotation_interfaces+=AnnotationInterfaceReference)* )? '{'
		(assignments+=LlmVariableAssignment)*
	'}' 
;

// the hidden () will forbid a whitespace between the @ and the referenced definition
AnnotationInterfaceReference hidden ():
	'@'name=[VMNodeDefinition]
;

LlmVariableAssignment:
	variablename=ID ':=' template=DataDictionaryValue
;



// ---------------------------------------
// workflows
// ---------------------------------------

WorkflowDefinition:
	'workflow' name=ID '(' input=[WorkflowInputDefinition] ',' datadictionary=[WorkflowDataDictionaryDefinition] ')' '{'
		(statements+=WorkflowDefinitionApplyLLMTaskStatement)*
	'}'
;


// We will start with a more general approach here, basically we need a DSL able to work with statements and expressions,
// also then the code generator needs to be redone.
// We want to support IF, ELSE, and FOR statements.
// continue, break, etc.
WorkflowIfStatement:
	'if' '(' condition = 'condition' ')' 
	'{'
	'}'
	( elsePresent?='else' '{' 
		
		'}' )?
;

WorkflowForStatement:
	'for'
;


WorkflowDefinitionApplyLLMTaskStatement:
	llmtask=[LlmTaskDefinition] '(' ')' 
	( '=>' 
		'{'
			(noderesultassigments+=WorkflowDefinitionApplyLLMNodeResultAssignment)*
		'}'  
	)?
	';'
;

WorkflowDefinitionApplyLLMNodeResultAssignment:
	// TODO: this should be a reference and the applicable parserrule is Qualified name
	environmentresultname=QualifiedName ':' noderesultname=QualifiedName;

// ---------------------------------------
// Common stuff
// ---------------------------------------


QualifiedName:
	ID ('.'ID)*
;
QualifiedNameWithWildcard:
	QualifiedName '.*'?
;



ELEMENTTYPE:
	BASICTYPE (isArray?='[' ']')?
;

// ALSO TODO: map, json, maybe upload should be some kind of object type
BASICTYPE:
	typename=('string'|'int'|'boolean'|'byte'|'jsonstring'|'upload')
;

terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'" |
			"'''"  -> "'''"
		;
terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS         : (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;
