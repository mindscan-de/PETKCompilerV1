grammar de.mindscan.ai.aidsl.AiDsl hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate aiDsl "http://www.mindscan.de/ai/aidsl/AiDsl"

Model:
	(package_declaration=PackageDeclaration)?
	
	(import_declarations+=ImportDeclaration)*
	
	definitions += (
		WorkflowDefinition|
		WorkflowDataDictionaryDefinition|
		WorkflowInputDefinition|
		LlmTaskDefinition|
		VMNodeDefinition
	)*
;

PackageDeclaration:
	'package' name=QualifiedName
;

ImportDeclaration:
	'import' importedNamespace=QualifiedNameWithWildcard
;

// should we reference the workflow or the oher way around?
WorkflowInputDefinition:
	'datainput' name=ID '{'
		(uiElements+=WorkflowUIElement)*
	'}'
;

WorkflowUIElement:
	name=QualifiedName ':' datatype=ELEMENTTYPE (uielement=WorkflowUIElementMap)? 
;

WorkflowUIElementMap:
	'ui' '{'
		'label' label=STRING
		'uitype' uitype=STRING
		// TODO basically an array of strings 
		('options' '[' options+=STRING(',' options+=STRING) ']')?
	'}'
;

// ---------------------------------------
// Workflow Data Defitinion / 
// Workflow Data Dictionary
// ---------------------------------------
//
// ---------------------------------------

WorkflowDataDictionaryDefinition:
	'datadictionary' name=ID '{'
		(keyValuePairs+=DatadictionaryKeyValuePair)*
	'}'
;

DatadictionaryKeyValuePair:
	name=ID ('extends' extends=[DatadictionaryKeyValuePair])? ':' value=DataDictionaryValue
;

// TODO: we want also integers/numbers
DataDictionaryValue:
		{DataDictionaryBooleanValue} DataDictionaryBooleanValue|
		{DataDictionaryStringValue} DataDictionaryStringValue|
		{DataDictionaryNullValue} DataDictionaryNullValue|
		DataDictionaryArrayValue|
		DataDictionaryMapValue
;

DataDictionaryArrayValue:
	 {DataDictionaryArrayValue} 
	 '[' (values+=STRING (',' values+=STRING)*)? ']'
;

DataDictionaryMapValue:
	 {DataDictionaryMapValue}  
	 '{' (keyValuePairs+=DatadictionaryKeyValuePair)* '}'
;


DataDictionaryBooleanValue:
	'true'|'false'
;
DataDictionaryStringValue:
	STRING
;
DataDictionaryNullValue:
	'null'
;

// ---------------------------------------
// VMNode stuff
// ---------------------------------------
//  
// ---------------------------------------

VMNodeDefinition:
	'vmnode' (nodetype=('super'|'overlay'))? name=ID '{'
		(elements+=VMNodeEleemnts)*
	'}'
;

VMNodeEleemnts:
	(
		VMNodeOpCodeElement|
		VMNodeOutElements|
		VMNodeInElements|
		VMNodeFieldElements
	)
;


VMNodeOpCodeElement:
	'opcode' opcode=STRING
;

VMNodeOutElements:
	{VMNodeOutElements} 'out' '{'
		(outElements+=VMNodeOutElement)* 
	'}'
;

VMNodeInElements:
	{VMNodeInElements} 'in' '{'
		(inElements+=VMNodeInElement)*
	'}'
;

VMNodeFieldElements:
	{VMNodeFieldElements} 'fields' '{'
		(fieldELements+=(VMFieldElement|VMOverrideFieldElement))*
	'}'
;

VMNodeOutElement:
	name=QualifiedName 'as' type=ELEMENTTYPE (hasrequire?='require' inputreference=QualifiedName)?
;

VMNodeInElement:
	(policy=('require'|'optional'))? name=QualifiedName
;

VMFieldElement:
	policy=('require'|'optional') type=ELEMENTTYPE name=ID ('default' defaultvalue=(STRING))?
;

VMOverrideFieldElement:
	policy=('override') type=ELEMENTTYPE name=ID ':=' defaultvalue=(STRING)
;

// ---------------------------------------
// LLM Task definition
// ---------------------------------------
// 
// ---------------------------------------

LlmTaskDefinition:
	'llmtask' name=ID '(' ')' ('implements' annotation_interfaces+=AnnotationInterfaceReference (',' annotation_interfaces+=AnnotationInterfaceReference)* )? '{'
		(assignments+=LlmVariableAssignment)*
	'}' 
;

// the hidden () will forbid a whitespace between the @ and the referenced definition
AnnotationInterfaceReference hidden ():
	'@'name=[VMNodeDefinition]
;

LlmVariableAssignment:
	variablename=ID ':=' template=STRING
;



// ---------------------------------------
// workflows
// ---------------------------------------

WorkflowDefinition:
	'workflow' name=ID '(' input=[WorkflowInputDefinition] ',' datadictionary=[WorkflowDataDictionaryDefinition] ')' '{'
		(statements+=WorkflowDefinitionApplyLLMTaskStatement)*
	'}'
;

WorkflowDefinitionApplyLLMTaskStatement:
	llmtask=[LlmTaskDefinition] '(' ')' 
	( '=>' 
		'{'
			(noderesultassigments+=WorkflowDefinitionApplyLLMNodeResultAssignment)*
		'}'  
	)?
	';'
;

WorkflowDefinitionApplyLLMNodeResultAssignment:
	// TODO: this should be a reference and the applicable parserrule is Qualified name
	environmentresultname=QualifiedName ':' noderesultname=QualifiedName;

// ---------------------------------------
// Common stuff
// ---------------------------------------


QualifiedName:
	ID ('.'ID)*
;
QualifiedNameWithWildcard:
	QualifiedName '.*'?
;



ELEMENTTYPE:
	BASICTYPE
;

BASICTYPE:
	typename=('string'|'int'|'boolean'|'jsonstring'|'upload')
;

terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'" |
			"'''"  -> "'''"
		;
terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS         : (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;
